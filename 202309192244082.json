{
    "IDDR": {
        "prefix": "ddr",
        "body" : [
            "IDDR #(",
            "    // \"OPPOSITE_EDGE\", \"SAME_EDGE\" or \"SAME_EDGE_PIPELINED\" ",
            "    .DDR_CLK_EDGE(\"SAME_EDGE\"), ",
            "    .INIT_Q1(1'b0),      // Initial value of Q1: 1'b0 or 1'b1",
            "    .INIT_Q2(1'b0),      // Initial value of Q2: 1'b0 or 1'b1",
            "    .SRTYPE(\"SYNC\"))     // Set/Reset type: \"SYNC\" or \"ASYNC\" ",
            "IDDR_inst (",
            "IDDR #(",
            "    .Q1(rx_data_pos),    // 1-bit output for positive edge of clock ",
            "    .Q2(rx_data_neg),    // 1-bit output for negative edge of clock",
            "    .C(data_clk),        // 1-bit clock input",
            "    .CE(1'b1),           // 1-bit clock enable input",
            "    .D(rx_data_dly),     // 1-bit DDR data input",
            "    .R(1'b0),            // 1-bit reset",
            "    .S(1'b0)             // 1-bit set",
            ");"
        ]
    },

    "ODDR": {
        "prefix": "ddr",
        "body" : [
            "ODDR #(",
            "    .DDR_CLK_EDGE(\"SAME_EDGE\"), // \"OPPOSITE_EDGE\" or \"SAME_EDGE\" ",
            "    .INIT(1'b0),        // Initial value of Q: 1'b0 or 1'b1",
            "    .SRTYPE(\"SYNC\"))    // Set/Reset type: \"SYNC\" or \"ASYNC\" ",
            "ODDR_inst (",
            "    .Q(odata),          // 1-bit DDR output",
            "    .C(data_clk),       // 1-bit clock input",
            "    .CE(1'b1),          // 1-bit clock enable input",
            "    .D1(data_p),        // 1-bit data input (positive edge)",
            "    .D2(data_n),        // 1-bit data input (negative edge)",
            "    .R(1'b0),           // 1-bit reset",
            "    .S(1'b0)            // 1-bit set",
            ");"
        ]
    },

    "OBUFDS": {
        "prefix": "obuf",
        "body" : [
            "OBUFDS #(",
            "    .IOSTANDARD(\"LVDS18\"), // Specify the output I/O standard",
            "    .SLEW(\"SLOW\"))         // Specify the output slew rate",
            "OBUFDS_inst (",
            "    .O(tx_frame_p),  // Diff_p output (connect directly to top-level port)",
            "    .OB(tx_frame_n), // Diff_n output (connect directly to top-level port)",
            "    .I(tx_frame)     // Buffer input ",
            ");"
        ]
    },

    "IBUFDS": {
        "prefix": "ibuf",
        "body" : [
            "IBUFDS #(",
            "    .DIFF_TERM(\"FALSE\"),       // Differential Termination",
            "    .IBUF_LOW_PWR(\"TRUE\"),     // Low power=\"TRUE\", Highest performance=\"FALSE\" ",
            "    .IOSTANDARD(\"DEFAULT\"))    // Specify the input I/O standard",
            "IBUFDS_inst (",
            "    .O(data_clk_tmp),   // Buffer output",
            "    .I(data_clk_p),     // Diff_p buffer input (connect directly to top-level port)",
            "    .IB(data_clk_n)     // Diff_n buffer input (connect directly to top-level port)",
            ");"
        ]
    },

    "OSERDESE2": {
        "prefix": "serd",
        "body" : [
        "OSERDESE2 #(",
        "    .DATA_RATE_OQ(\"DDR\"),   // DDR, SDR",
        "    .DATA_RATE_TQ(\"DDR\"),   // DDR, BUF, SDR",
        "    .DATA_WIDTH(4),         // Parallel data width (2-8,10,14)",
        "    .INIT_OQ(1'b0),         // Initial value of OQ output (1'b0,1'b1)",
        "    .INIT_TQ(1'b0),         // Initial value of TQ output (1'b0,1'b1)",
        "    .SERDES_MODE(\"MASTER\"), // MASTER, SLAVE",
        "    .SRVAL_OQ(1'b0),        // OQ output value when SR is used (1'b0,1'b1)",
        "    .SRVAL_TQ(1'b0),        // TQ output value when SR is used (1'b0,1'b1)",
        "    .TBYTE_CTL(\"FALSE\"),    // Enable tristate byte operation (FALSE, TRUE)",
        "    .TBYTE_SRC(\"FALSE\"),    // Tristate byte source (FALSE, TRUE)",
        "    .TRISTATE_WIDTH(4)      // 3-state converter width (1,4)",
        ")",
        "OSERDESE2_inst (",
        "    .OFB(OFB),             // 1-bit output: Feedback path for data",
        "    .OQ(OQ),               // 1-bit output: Data path output",
        "    // SHIFTOUT1 / SHIFTOUT2: 1-bit (each) output: Data output expansion (1-bit each)",
        "    .SHIFTOUT1(SHIFTOUT1),",
        "    .SHIFTOUT2(SHIFTOUT2),",
        "    .TBYTEOUT(TBYTEOUT),   // 1-bit output: Byte group tristate",
        "    .TFB(TFB),             // 1-bit output: 3-state control",
        "    .TQ(TQ),               // 1-bit output: 3-state control",
        "    .CLK(CLK),             // 1-bit input: High speed clock",
        "    .CLKDIV(CLKDIV),       // 1-bit input: Divided clock",
        "    // D1 - D8: 1-bit (each) input: Parallel data inputs (1-bit each)",
        "    .D1(D1),",
        "    .D2(D2),",
        "    .D3(D3),",
        "    .D4(D4),",
        "    .D5(D5),",
        "    .D6(D6),",
        "    .D7(D7),",
        "    .D8(D8),",
        "    .OCE(OCE),             // 1-bit input: Output data clock enable",
        "    .RST(RST),             // 1-bit input: Reset",
        "    // SHIFTIN1 / SHIFTIN2: 1-bit (each) input: Data input expansion (1-bit each)",
        "    .SHIFTIN1(SHIFTIN1),",
        "    .SHIFTIN2(SHIFTIN2),",
        "    // T1 - T4: 1-bit (each) input: Parallel 3-state inputs",
        "    .T1(T1),",
        "    .T2(T2),",
        "    .T3(T3),",
        "    .T4(T4),",
        "    .TBYTEIN(TBYTEIN),     // 1-bit input: Byte group tristate",
        "    .TCE(TCE)              // 1-bit input: 3-state clock enable",
        ");"
        ]
    },

    "ISERDESE2": {
        "prefix": "serd",
        "body" : [
        "ISERDESE2 #(",
        "    .DATA_RATE(\"DDR\"),           // DDR, SDR",
        "    .DATA_WIDTH(4),              // Parallel data width (2-8,10,14)",
        "    .DYN_CLKDIV_INV_EN(\"FALSE\"), // Enable DYNCLKDIVINVSEL inversion (FALSE, TRUE)",
        "    .DYN_CLK_INV_EN(\"FALSE\"),    // Enable DYNCLKINVSEL inversion (FALSE, TRUE)",
        "    // INIT_Q1 - INIT_Q4: Initial value on the Q outputs (0/1)",
        "    .INIT_Q1(1'b0),",
        "    .INIT_Q2(1'b0),",
        "    .INIT_Q3(1'b0),",
        "    .INIT_Q4(1'b0),",
        "    .INTERFACE_TYPE(\"MEMORY\"),   // MEMORY, MEMORY_DDR3, MEMORY_QDR, NETWORKING, OVERSAMPLE",
        "    .IOBDELAY(\"NONE\"),           // NONE, BOTH, IBUF, IFD",
        "    .NUM_CE(2),                  // Number of clock enables (1,2)",
        "    .OFB_USED(\"FALSE\"),          // Select OFB path (FALSE, TRUE)",
        "    .SERDES_MODE(\"MASTER\"),      // MASTER, SLAVE",
        "    // SRVAL_Q1 - SRVAL_Q4: Q output values when SR is used (0/1)",
        "    .SRVAL_Q1(1'b0),",
        "    .SRVAL_Q2(1'b0),",
        "    .SRVAL_Q3(1'b0),",
        "    .SRVAL_Q4(1'b0))",
        "ISERDESE2_inst (",
        "    .O(O),                       // 1-bit output: Combinatorial output",
        "    // Q1 - Q8: 1-bit (each) output: Registered data outputs",
        "    .Q1(Q1),",
        "    .Q2(Q2),",
        "    .Q3(Q3),",
        "    .Q4(Q4),",
        "    .Q5(Q5),",
        "    .Q6(Q6),",
        "    .Q7(Q7),",
        "    .Q8(Q8),",
        "    // SHIFTOUT1, SHIFTOUT2: 1-bit (each) output: Data width expansion output ports",
        "    .SHIFTOUT1(SHIFTOUT1),",
        "    .SHIFTOUT2(SHIFTOUT2),",
        "\n",    
        "    // 1-bit input: The BITSLIP pin performs a Bitslip operation synchronous to",
        "    // CLKDIV when asserted (active High). Subsequently, the data seen on the Q1",
        "    // to Q8 output ports will shift, as in a barrel-shifter operation, one",
        "    // position every time Bitslip is invoked (DDR operation is different from",
        "    // SDR).",
        "    .BITSLIP(BITSLIP), ",     
        "\n",
        "    // CE1, CE2: 1-bit (each) input: Data register clock enable inputs",
        "    .CE1(CE1),",
        "    .CE2(CE2),",
        "    .CLKDIVP(CLKDIVP),           // 1-bit input: TBD",
        "    // Clocks: 1-bit (each) input: ISERDESE2 clock input ports",
        "    .CLK(CLK),                   // 1-bit input: High-speed clock",
        "    .CLKB(CLKB),                 // 1-bit input: High-speed secondary clock",
        "    .CLKDIV(CLKDIV),             // 1-bit input: Divided clock",
        "    .OCLK(OCLK),                 // 1-bit input: High speed output clock used when INTERFACE_TYPE=\"MEMORY\" ",
        "    // Dynamic Clock Inversions: 1-bit (each) input: Dynamic clock inversion pins to switch clock polarity",
        "    .DYNCLKDIVSEL(DYNCLKDIVSEL), // 1-bit input: Dynamic CLKDIV inversion",
        "    .DYNCLKSEL(DYNCLKSEL),       // 1-bit input: Dynamic CLK/CLKB inversion",
        "    // Input Data: 1-bit (each) input: ISERDESE2 data input ports",
        "    .D(D),                       // 1-bit input: Data input",
        "    .DDLY(DDLY),                 // 1-bit input: Serial data from IDELAYE2",
        "    .OFB(OFB),                   // 1-bit input: Data feedback from OSERDESE2",
        "    .OCLKB(OCLKB),               // 1-bit input: High speed negative edge output clock",
        "    .RST(RST),                   // 1-bit input: Active high asynchronous reset",
        "    // SHIFTIN1, SHIFTIN2: 1-bit (each) input: Data width expansion input ports",
        "    .SHIFTIN1(SHIFTIN1),",
        "    .SHIFTIN2(SHIFTIN2)",
        ");"
        ]
    },

    "testbench template": {
        "prefix": ["tb", "testbench"],
        "body": [
            "`include \"$1.v\"",
            "`timescale 1ns/1ps",
            "",
            "module tb_$1;",
            "reg clk;",
            "reg rst_n;",
            "",
            "$1 $3",
            "(",
            "\t.rst_n (rst_n),",
            "\t.clk (clk),",
            ");",
            "",
            "localparam CLK_PERIOD = 10;",
            "always #(CLK_PERIOD/2) clk=~clk;",
            "",
            "initial begin",
            "\t\\$dumpfile(\"tb_$1.vcd\");",
            "\t\\$dumpvars(0, tb_$1);",
            "end",
            "",
            "initial begin",
            "\t#1 rst_n<=1'bx;clk<=1'bx;",
            "\t#(CLK_PERIOD*3) rst_n<=1;",
            "\t#(CLK_PERIOD*3) rst_n<=0;clk<=0;",
            "\trepeat(5) @(posedge clk);",
            "\trst_n<=1;",
            "\t@(posedge clk);",
            "\trepeat(2) @(posedge clk);",
            "\t\\$finish(2);",
            "end",
            "",
            "endmodule"
            
        ],
        "description": "testbench template"
    },

    "Shixu": {
        "prefix": "Shixu",
        "body": [
            "reg [${1:DATA_W} - 1 : 0] ${2:reg_name};//",
            "always@(posedge clk or negedge rst_n)begin",
                "\tif(rst_n==1'b0)begin//初始值为0;",
                    "\t\t${2:reg_name} <= {{${1:DATA_W}}{1'b0}};",
                "\tend",
                "\telse begin",
                    "\t\t${2:reg_name} <= ${3:val};",
                "\tend",
            "end"
        ]
    },

    "Shixu2": {
        "prefix": "Shixu2",
        "body": [
            "reg [${1:DATA_W} - 1 : 0] ${2:reg_name};//",
            "always@(posedge clk or negedge rst_n)begin",
                "\tif(rst_n==1'b0)begin//初始值为0;",
                    "\t\t${2:reg_name} <= {{${1:DATA_W}}{1'b0}};",
                "\tend",
                "\telse if(${3:condition1})begin",
                    "\t\t${2:reg_name} <= ${4:val1};",
                "\tend",
                "\telse if(${5:condition2})begin",
                    "\t\t${2:reg_name} <= ${6:val2};",
                "\tend",
            "end"
        ]
    },

    "Shixu3": {
        "prefix": "Shixu3",
        "body": [
            "reg [${1:DATA_W} : 0] ${2:reg_name};//",
            "always@(posedge clk or negedge rst_n)begin",
                "\tif(rst_n==1'b0)begin//初始值为0;",
                    "\t\t${2:reg_name} <= {{${1:DATA_W}}{1'b0}};",
                "\tend",
                "\telse if(${3:condition1})begin",
                    "\t\t${2:reg_name} <= ${4:val1};",
                "\tend",
                "\telse if(${5:condition2})begin",
                    "\t\t${2:reg_name} <= ${6:val2};",
                "\tend",
                "\telse if(${7:condition3})begin",
                    "\t\t${2:reg_name} <= ${8:val3};",
                "\tend",
            "end"
        ]
    },
    
    "Jsq": {
        "prefix": ["jsq", "counter"],
        "body": [
            "//define the time counter",
            "reg [${1:32}:0]      cnt$2 = 0;",
            "reg             ${3:impulse};",
            "parameter       SET_TIME = $1'd$4;",
            "always@(posedge clk) begin",
            "    if (cnt$2 == SET_TIME) begin",
            "        cnt$2 <= $1'd0;",
            "        $3 <= 1'd1;",
            "    end",
            "    else begin",
            "        cnt$2 <= cnt$2 + 1'd1;",
            "        $3 <= 1'd0;",
            "    end",
            "end"
        ]
    },
    "Jsq1": {
        "prefix": ["jsq", "counter"],
        "body": [
            "//define the time counter",
            "reg\t[$1:0] \t${2:cnt};",
            "wire       \tadd_${2:cnt};",
            "wire       \tend_${2:cnt};",
            "",
            "always@(posedge clk or negedge rst_n) begin",
            "    \tif (rst_n == 1'b0) begin",
            "    \t\t${2:cnt} <= $1'd0;",
            "    \tend",
            "    \telse if(add_${2:cnt})begin",
            "        \t\tif(end_${2:cnt})",
            "        \t\t\t${2:cnt} <= 0;",
            "        \t\telse",
            "        \t\t\t${2:cnt} <= ${2:cnt} + 1;",
            "     \tend",
            "    end",
            "",
            "assign add_${2:cnt} = $3;",
            "assign end_${2:cnt} = add_${2:cnt} && ${2:cnt} == $4 - 1;"            
        ]
    },
    	
		"Jsq2": {
			"prefix": ["jsq", "counter"],
			"body": [
				"reg [$1 : 0]\t${2:cnt0};//",
				"reg [$5 : 0]\t${6:cnt1};//",
				"wire       \t\tadd_${2:cnt0};",
				"wire       \t\tend_${2:cnt0};",
				"wire       \t\tadd_${6:cnt1};",
				"wire       \t\tend_${6:cnt1};",
				"",
				"always@(posedge clk or negedge rst_n)begin",
					"\tif(rst_n==1'b0)begin//",
						"\t\t${2:cnt0} <= 0;",
					"\tend",
					"\telse if(add_${2:cnt0})begin",
						"\t\tif(end_${2:cnt0})",
							"\t\t\t${2:cnt0} <= 0;",
						"\t\telse",
							"\t\t\t${2:cnt0} <= ${2:cnt0} + 1;",
					"\tend",
				"end",
				"",
				"assign add_${2:cnt0} = $3;",
				"assign end_${2:cnt0} = add_${2:cnt0} && ${2:cnt0} == $4 - 1;",
				"",
				"always@(posedge clk or negedge rst_n)begin",
					"\tif(rst_n==1'b0)begin//",
						"\t\t${6:cnt1} <= 0;",
					"\tend",
					"\telse if(add_${6:cnt1})begin",
						"\t\tif(end_${6:cnt1})",
							"\t\t\t${6:cnt1} <= 0;",
						"\t\telse",
							"\t\t\t${6:cnt1} <= ${6:cnt1} + 1;",
					"\tend",
				"end",
				"",
				"assign add_${6:cnt1} = end_${2:cnt0};",
				"assign end_${6:cnt1} = add_${6:cnt1} && ${6:cnt1} == $7 - 1;"
			]
		},
	
		"Jsq3": {
			"prefix": ["jsq", "counter"],
			"body": [
				"reg [$1:0] \t${2:cnt0};//",
				"reg [$5:0] \t${6:cnt1} ;//",
				"reg [$8:0] \t${9:cnt2} ;//",
				"wire       \t\tadd_${2:cnt0};",
				"wire       \t\tend_${2:cnt0};",
				"wire       \t\tadd_${6:cnt1} ;",
				"wire       \t\tend_${6:cnt1} ;",
				"wire       \t\tadd_${9:cnt2} ;",
				"wire       \t\tend_${9:cnt2} ;",
				"",
				"always@(posedge clk or negedge rst_n)begin",
					"\tif(rst_n==1'b0)begin//",
						"\t\t${2:cnt0} <= 0;",
					"\tend",
					"\telse if(add_${2:cnt0})begin",
						"\t\tif(end_${2:cnt0})",
							"\t\t\t${2:cnt0} <= 0;",
						"\t\telse",
							"\t\t\t${2:cnt0} <= ${2:cnt0} + 1;",
					"\tend",
				"end",
				"",
				"assign add_${2:cnt0} = $3;",
				"assign end_${2:cnt0} = add_${2:cnt0} && ${2:cnt0} == $4 - 1;",
				"",
				"always@(posedge clk or negedge rst_n)begin",
					"\tif(rst_n==1'b0)begin//",
						"\t\t${6:cnt1} <= 0;",
					"\tend",
					"\telse if(add_${6:cnt1})begin",
						"\t\tif(end_${6:cnt1})",
							"\t\t\t${6:cnt1} <= 0;",
						"\t\telse",
							"\t\t\t${6:cnt1} <= ${6:cnt1} + 1;",
					"\tend",
				"end",
				"",
				"assign add_${6:cnt1} = end_${2:cnt0};",
				"assign end_${6:cnt1} = add_${6:cnt1} && ${6:cnt1}  == $7 - 1;",
				"",
				"always@(posedge clk or negedge rst_n)begin",
					"\tif(rst_n==1'b0)begin//",
						"\t\t${9:cnt2} <= 0;",
					"\tend",
					"\telse if(add_${9:cnt2})begin",
						"\t\tif(end_${9:cnt2})",
							"\t\t\t${9:cnt2} <= 0;",
						"\t\telse",
							"\t\t\t${9:cnt2} <= ${9:cnt2} + 1;",
					"\tend",
				"end",
				"",
				"assign add_${9:cnt2} = end_${6:cnt1};",
				"assign end_${9:cnt2} = add_${9:cnt2} && ${9:cnt2} == $10 - 1;"
			]
		},
	
        "module with parameters": {
            "prefix": "modulep",
            "body": [
                "module $TM_FILENAME_BASE #(",
                "    parameter    INPUT_WIDTH  = ${2:12},",
                "    parameter    OUTPUT_WIDTH = $2",
                ") (",
                "    input      clk,",
                "    input      RST,",
                "    input  [INPUT_WIDTH - 1 : 0]    ${3:data_i},",
                "    output [OUTPUT_WIDTH - 1 : 0]   ${4:data_o}",
                ");",
                "    $5",
                "endmodule  //$1\n"
            ],
            "description": "Insert a module with parameter"
        },
    
        "module without parameters": {
            "prefix": "module",
            "body": [
                "module $TM_FILENAME_BASE (",
                "    input      clk,",
                "    input      RST,",
                "    $2",
                ");",
                "    $3",
                "endmodule //$1\n"
            ],
            "description": "Insert a module without parameter"
        },

		"Module_A": {
			"prefix": "Module_A",
			"body": [
				"module ${1:module_name} #(",
				"\tparameter\t\t\tAVALON_BUS_MODE\t\t=\t\t1\t\t\t\t,//Avalon-MM bus transport mode",
				"\tparameter\t\t\tAVS_ADDR_BIT\t\t=\t\t8\t\t\t\t,//Avalon-MM address signal bit width",
				"\tparameter\t\t\tAVS_DATA_BIT\t\t=\t\t16\t\t\t\t//Avalon-MM data bus bit width",
				")(",
				"\tinput\t\t\t\t\t\t\t\t\t\t\tclk\t\t\t\t,//System clock, 100MHz",
				"\tinput\t\t\t\t\t\t\t\t\t\t\trst_n\t\t\t,//System reset, active low",
				"",
				"\tinput\t\t\t\t\t\t\t\t\t\t\tavs_read\t\t,//Avalon reads the enable signal",
				"\tinput\t\t\t\t\t\t\t\t\t\t\tavs_write\t\t,//Avalon writes the enable signal",
				"\tinput\t\t\t\t[AVS_ADDR_BIT - 1\t: 0]\tavs_address\t\t,//Avalon-MM Address bus bus",
				"\tinput\t\t\t\t[AVS_DATA_BIT - 1\t: 0]\tavs_writedata\t,//Avalon-MM write data bus",
				"\toutput reg\t\t\t[AVS_DATA_BIT - 1\t: 0]\tavs_readdata\t//Avalon-MM Read data bus",
				"\t);",
				"\t$0",
				"endmodule"
			]
		},
	
		"Module": {
			"prefix": "Module",
			"body": [
				"module ${1:moduleName} #(",
				"\tparameter\t\t\t${2:DATA_W}\t\t=\t\t${3:8}\t\t,//Data bit width;",
				"\tparameter\t\t\t${4:TIME_20US}\t=\t\t${5:20_000}\t //20us Indicates the number of clocks;",
				")(",
					"\tinput\t\t\t\t\t\t\t\t\tclk\t\t,//System input clock;",
					"\tinput\t\t\t\t\t\t\t\t\trst_n\t,//The system resets. The default low level is valid;",
					"",
					"\tinput\t\t\t\t[${2:DATA_W} - 1 : 0]\tdin\t\t,//Input data signal;",
					"\tinput\t\t\t\t\t\t\t\t\tdin_vld\t,//Input data valid indication signal, high level is valid;",
					"\toutput reg\t\t\t[${2:DATA_W} - 1 : 0]\tdout\t,//Output data signal;",
					"\toutput reg\t\t\t\t\t\t\t\tdout_vld //Output data valid indication signal, high level is valid;",
					"\t);",
					"\t$0",
				"endmodule"
			]
		},
		"Module_中文注释_UTF8": {
			"prefix": "Module",
			"body": [
				"module ${1:moduleName} #(",
				"\tparameter\t\t\t${2:DATA_W}\t\t=\t\t${3:8}\t\t,//数据位宽；",
				"\tparameter\t\t\t${4:TIME_20US}\t=\t\t${5:20_000}\t //20us对应时钟个数；",
				")(",
					"\tinput\t\t\t\t\t\t\t\t\tclk\t\t,//系统时钟信号；",
					"\tinput\t\t\t\t\t\t\t\t\trst_n\t,//系统复位信号，低电平有效；",
					"",
					"\tinput\t\t\t\t[${2:DATA_W} - 1 : 0]\tdin\t\t,//输入数据；",
					"\tinput\t\t\t\t\t\t\t\t\tdin_vld\t,//输入数据有效指示信号，高电平有效；",
					"\toutput reg\t\t\t[${2:DATA_W} - 1 : 0]\tdout\t,//输出数据信号；",
					"\toutput reg\t\t\t\t\t\t\t\tdout_vld //输出数据有效指示信号，高电平有效；",
					"\t);",
					"\t$0",
				"endmodule"
			]
		},

        "State machine": {
			"prefix": ["ztj", "state"],
			"body": [
				"//Four-stage state machine;",
				"parameter\tIDLE = $1'd0;",
				"parameter\tS1\t = $1'd1;",
				"parameter\tS2\t = $1'd2;",
				"parameter\tS3\t = $1'd3;",
				"",
				"reg[$1-1:0]\tstate_n;",
				"reg[$1-1:0]\tstate_c;",
				"wire\t\tidl2s1_start;",
				"wire\t\ts12s2_start;",
				"wire\t\ts22s3_start;",
				"",
				"//The first section: synchronous timing always module, formatted to describe the transfer of the secondary register to the live register�?",
				"always@(posedge clk or negedge rst_n)begin",
				"\tif(!rst_n)begin",
				"\t\tstate_c <= IDLE;",
				"\tend",
				"\telse begin",
				"\t\tstate_c <= state_n;",
				"\tend",
				"end",
				"",
				"//The second paragraph: The combinational logic always module describes the state transition condition judgment.",
				"always@(*)begin",
				"\tcase(state_c)",
				"\t\tIDLE:begin",
				"\t\t\tif(idl2s1_start)begin",
				"\t\t\t\tstate_n = S1;",
				"\t\t\tend",
				"\t\t\telse begin",
				"\t\t\t\tstate_n = state_c;",
				"\t\t\tend",
				"\t\tend",
				"\t\tS1:begin",
				"\t\t\tif(s12s2_start)begin",
				"\t\t\t\tstate_n = S2;",
				"\t\t\tend",
				"\t\t\telse begin",
				"\t\t\t\tstate_n = state_c;",
				"\t\t\tend",
				"\t\tend",
				"\t\tS2:begin",
				"\t\t\tif(s22s3_start)begin",
				"\t\t\t\tstate_n = S3;",
				"\t\t\tend",
				"\t\t\telse begin",
				"\t\t\t\tstate_n = state_c;",
				"\t\t\tend",
				"\t\tend",
				"\t\tdefault:begin",
				"\t\t\tstate_n = IDLE;",
				"\t\tend",
				"\tendcase",
				"end",
				"// Third paragraph: Design transfer conditions�?",
				"assign idl2s1_start\t= state_c==IDLE\t&& $2;",
				"assign s12s2_start\t= state_c==S1\t&& $3;",
				"assign s22s3_start\t= state_c==S2\t&& $4;"
			]
		},
	
		"clogb2": {
			"prefix": "clogb2",
			"body": [
				"function integer clogb2(input integer depth);begin",
				"\tif(depth == 0)",
				"\t\tclogb2 = 1;",
				"\telse if(depth != 0)",
				"\t\tfor(clogb2=0 ; depth>0 ; clogb2=clogb2+1)",
				"\t\t\tdepth=depth >> 1;",
				"\tend",
				"endfunction"
			]
		},
	
		"Zuhe": {
			"prefix": ["comb", "zuhe"],
			"body": [
				"reg\t[$1:0]\t$2;",
				"always@(*)begin",
				"\t$2 = $3;",
				"end"
			]
		},
	
		"Zuhe2": {
			"prefix":["comb", "zuhe"],
			"body": [
				"reg\t[$1:0]\t$2;",
				"always@(*)begin",
				"\tif($3)begin",
				"\t\t$2 = $4;",
				"\tend",
				"\telse begin",
				"\t\t$2 = $5;",
				"\tend",
				"end"
			]
		},
	
		"Zuhe3": {
			"prefix": ["comb", "zuhe"],
			"body": [
				"reg\t[$1:0]\t$2;",
				"always@(*)begin",
				"\tif($3)begin",
				"\t\t$2 = $4;",
				"\tend",
				"\telse if($5)begin",
				"\t\t$2 = $6;",
				"\tend",
				"\telse begin",
				"\t\t$2 = $7;",
				"\tend",
				"end"
			]
		},
	
		"Zuhe4": {
			"prefix": ["comb", "zuhe"],
			"body": [
				"reg\t[$1:0]\t$2;",
				"always@(*)begin",
				"\tif($3)begin",
				"\t\t$2 = $4;",
				"\tend",
				"\telse if($5)begin",
				"\t\t$2 = $6;",
				"\tend",
				"\telse if($7)begin",
				"\t\t$2 = $8;",
				"\tend",
				"\telse begin",
				"\t\t$2 = $9;",
				"\tend",
				"end"
			]
		},
	
		"Zhushi": {
			"prefix": ["header", "zhushi"],
			"body": [
				"//--###############################################################################################",
				"//--#",
				"//--# File Name\t\t: $1",
				"//--# Designer\t\t: $2",
				"//--# Tool\t\t\t: Quartus II$3",
				"//--# Checked by\t: $4",
				"//--# Design Date\t: 20",
				"//--# Description\t: $5",
				"//--# Version\t\t: $6",
				"//--# History\t\t: $7",
				"//--#",
				"//--###############################################################################################"
			]
		},
		"singalZhushi": {
			"prefix": ["header", "zhushi"],
			"body": [
				"/**************************\t$1\t********************************/"
			]
		},

    "clk_div": {
        "prefix": "div",
        "body": [
            "reg [${1:3}:0]      cnt$2 = 0;",
            "reg                 clk_div$2;",
            "always@(posedge ${3:clk}) begin",
            "    if (cnt$2 == ${4:3}) begin",
            "        cnt$2 <= $1'd0;",
            "        clk_div$2 <= ~clk_div$2;",
            "    end",
            "    else begin",
            "        cnt$2 <= cnt$2 + 1'd1;",
            "    end",
            "end"
        ]
    },

    "lock": {
        "prefix": "lock",
        "body": [
            "reg  gate$2;",
            "reg  gate$2_buf;",
    
            "wire gate$2_pose =  gate$2 & ~gate$2_buf;",
            "wire gate$2_nege =  ~gate$2 & gate$2_buf;",
    
            "always@(posedge clk) begin",
            "   gate$2 <= ${1:signal};",
            "   gate$2_buf <= gate$2;",
            "end"
        ]
    },

    "posedge": {
        "prefix": "pos",
        "body": [
            "posedge"
        ]
    },

    "negedge": {
        "prefix": "neg",
        "body": [
            "negedge"
        ]
    },

    "resetn": {
        "prefix": "resetn",
        "body": [
            "reg  rst_n_s1, rst_n_s2;",
            "wire rst_n",
            "always @ (posedge clk or negedge sys_rst_n) begin",
            "    if (sys_rst_n) begin",
            "        rst_n_s2 <= 1'b0;",
            "        rst_n_s1 <= 1'b0;",
            "    end",
            "        rst_n_s1 <= 1'b1;",
            "        rst_n_s2 <= rst_n_s1;",
            "    end",
            "end",
            "assign rst_n = rst_n_s2;"
        ],
        "description" : "Asynchronous sys_rst_n synchronous release (intel device)"
    },

    "reset": {
        "prefix": "reset",
        "body": [
            "reg  rst_s1, rst_s2;",
            "wire rst",
            "always @ (posedge clk or posedge sys_rst) begin",
            "    if (sys_rst) begin",
            "        rst_s2 <= 1'b0;",
            "        rst_s1 <= 1'b0;",
            "    end",
            "        rst_s1 <= 1'b1;",
            "        rst_s2 <= rst_s1;",
            "    end",
            "end",
            "assign rst = rst_s2;"
        ],
        "description" : "Asynchronous sys_rst synchronous release (xilinx device)"
    },
        
    "initial sim": {
        "prefix": "vcd",
        "body": [
            "initial begin",
            "   \\$dumpfile(\"wave.vcd\");",
            "   \\$dumpvars(0, ${1:testbench});",                     
            "   #6000 \\$finish;",                      
            "end"
        ],
        "description": "initial for simulation"
    },

    "initial array": {
        "prefix":[ "inita","for"],
        "body": [
            "integer ${1:i};",
            "initial begin",
            "   for ($1 = 0; $1<${2:range}; $1=$1+1) begin",
            "        ${3:data}[$1] = 0;",
            "    end",   
            "end"
        ],
        "description": "initial for a array"
    },
	"initial": {
		"prefix": "initial",
		"body": [
			"initial begin",
			"\t$0",
			"end"
		],
		"description": "initial begin ... end"
	},

    "debug": {
        "prefix": "debug",
        "body": ["(* mark_debug = \"true\" *)"]
    },

    "same instantiate ": {
		"prefix": ["set module", "instantiate module"],
		"body": [
			"${1:mod_name} ${2:instance_name} (",
			"\t.$3($3),",
			"\t.$4($4),",
			"\t.$5($5)",
			");"
		],
		"description": "same ins"
	},
	" instantiate ": {
		"prefix": ["set module", "instantiate module"],
		"body": [
			"${1:mod_name} ${2:instance_name} (",
			"\t.$3($4),",
			"\t.$5($6),",
			"\t.$7($8)",
			");"
		],
		"description": " ins"
	},

    "timescale": {
        "prefix": "time",
        "body": ["`timescale 1ns / 1ps"]
    },

    "assign": {
        "prefix": "assign",
        "body": ["assign $1 = $2;"]
    },

    "always_ff block": {
        "prefix": "ff",
        "body": [
            "always_ff @( ${1:clock} ) begin : ${2:blockName}",
            "    $0;",
            "end"
        ],
        "description": "Insert an always_ff block"
    },

    "always_comb block": {
        "prefix": "comb",
        "body": [
            "always_comb begin : ${1:blockName}",
            "    $0;",
            "end"
        ],
        "description": "Insert an always_comb block"
    },

    "always": {
        "prefix": "always",
        "body": [
            "always @(*) begin",
            "    $1;",
            "end"
        ],
        "description": "always @(*)"
    },

    "alwaysposclk": {
        "prefix": "alclk",
        "body": [
            "always @(posedge clk) begin",
            "    $1;",
            "end"
        ],
        "description": "always @(posedge clk) directly"
    },

    "alwayssyncrst": {
        "prefix": "alwayssync",
        "body": [
            "always @(posedge clk) begin",
            "    if(rst) begin",
            "        $1 <= 0;",
            "    end",
            "    else begin",
            "        $2 <= $3;",
            "    end",
            "end"
        ],
        "description": "synchronous rst (xilinx device)"
    },

    "alwaysasyncrst": {
        "prefix": "alwaysasync",
        "body": [
            "always @(posedge clk or posedge rst) begin",
            "    if(rst) begin",
            "        $1 <= 0;",
            "    end",
            "    else begin",
            "        $2 <= $3;",
            "    end",
            "end"
        ],
        "description": "asynchronous rst (xilinx device)"
    },

    "alwayssyncrstn": {
        "prefix": "alwayssyncn",
        "body": [
            "//同步复位",
            "always @(posedge clk) begin",
            "    if(!rst_n) begin",
            "        $1 <= 0;",
            "    end",
            "    else begin",
            "        $2 <= $3;",
            "    end",
            "end"
        ],
        "description": "synchronous rst_n (intel device)"
    },

    "alwaysasyncrstn": {
        "prefix": "alwaysasyncn",
        "body": [
            "//异步复位",
            "always @(posedge clk or negedge rst_n) begin",
            "    if(!rst_n) begin",
            "        $1 <= 0;",
            "    end",
            "    else begin",
            "        $2 <= $3;",
            "    end",
            "end"
        ],
        "description": "asynchronous rst_n (intel device)"
    },

    "beginend": {
        "prefix": "beginend",
        "body": [
            "begin",
            "    $1",
            "end"
        ],
        "description": "begin ... end"
    },

    "case": {
        "prefix": "case",
        "body": [
            "case (${1:conditions})",
            "    $2: $3",
            "\tdefault: $4",
            "endcase"
        ],
        "description": "case () ... endcase"
    },
    "casex": {
		"prefix": "casex",
		"body": [
			"casex (${1:param})",
			"\t$2: $3",
			"\tdefault: $4",
			"endcase"
		],
		"description": "casex () ... endcase"
	},
	"casez": {
		"prefix": "casez",
		"body": [
			"casez (${1:param})",
			"\t$2: $3",
			"\tdefault: $4",
			"endcase"
		],
		"description": "casez () ... endcase"
	},

    "genvar": {
		"prefix": "genvar",
		"body": "genvar $1",
		"description": "genvar i"
	},

    "generate_for": {
        "prefix": "genfor",
        "body": [
            "genvar ${1:i};",
            "generate for($1 = 0 ; $1 < $2; $1 = $1 + 1) ",
            "begin : ${3:U}",
            "    $4",
            "end",
            "endgenerate"
        ]
    },
    
    "generate_if": {
        "prefix": "genif",
        "body": [
            "generate if(${1:conditional})",
            "begin : ${2:U}",
            "    ${3:}",
            "end",
            "endgenerate"
        ]
    },
    
    "generate_case": {
        "prefix": "gencase",
        "body": [
            "generate",
            "case (${1:NUM})",
            "32'd1 : begin : ${2:case1_name}",
            "$3",
            "        end",
            "32'd2 : begin : ${4:case1_name}",
            "$5",
            "        end",
            "default : begin : NOP end",
            "endcase",
            "endgenerate"
        ]
    },    

    "if block": {
        "prefix": "if",
        "body": [
            "if (${1:conditions}) begin",
            "    $0",
            "end"
        ],
        "description": "Insert a if block"
    },

    "include": {
		"prefix": "inc",
		"body": [
			"`include \"$1\""
		],
		"description": "`include \"..\""
	},

    "define": {
        "prefix": ["def", "define", "`define"],
		"body": [
			"`def $1 = $2"
		],
		"description": "`define var = val"
	},
    
    "default_nettype": {
		"prefix": ["default_nettype", "`default_nettype"],
		"body": "`default_nettype ${1:none}",
		"description": "Set default nettype"
	},

	"ifdef": {
		"prefix": ["ifdef", "`ifdef"],
		"body": "`ifdef ${1:macro}",
		"description": "`ifdef macro"
	},
	"ifndef": {
		"prefix": ["ifndef", "`ifndef"],
		"body": "`ifndef ${1:macro}",
		"description": "`ifndef macro"
	},
	"elsif": {
		"prefix": ["elsif", "`elsif"],
		"body": "`elsif ${1:macro}",
		"description": "`elsif macro"
	},
	"endif": {
		"prefix": ["endif", "`endif"],
		"body": "`endif ${1:macro}",
		"description": "`endif macro"
	},
	"undef": {
		"prefix": ["undef", "`undef"],
		"body": "`undef ${1:macro}",
		"description": "`undef macro"
	},

	"parameter": {
		"prefix": "parameter",
		"body": [
			"parameter $1 = $2;"
		],
		"description": "paramter var = val;"
	},

    "localparam": {
		"prefix": "localparam",
		"body": [
			"localparam $1 = $2;"
		],
		"description": "localparam var = val;"
	},

    "integer": {
		"prefix": "integer",
		"body": "integer $1;",
		"description": "integer int_name"
	},
	"signed": {
		"prefix": "signed",
		"body": "signed $1 $2;",
		"description": "signed datatype name"
	},

	"ternary": {
		"prefix": "if",
		"body": [
			"$1 ? $2 : $3"
		],
		"description": "a ? b : c"
	},

	"ifelse": {
		"prefix": "ifelse",
		"body": [
			"if (${1:conditions}) begin",
			"    $2",
			"end",
            "else begin",
			"    $3",
            "end"
		],
		"description": "if (...) begin ... end else begin ... end"
	},

    "else": {
		"prefix": "else",
		"body": [
            "else begin",
			"    $1",
            "end"
		],
		"description": "else begin ... end"
	},

    "elseif": {
		"prefix": "elseif",
		"body": [
            "else if(${1:conditions}) begin",
			"    $2",
            "end"
		],
		"description": "else if(conditions) begin ... end"
	},

    "for loop": {
		"prefix": "for",
		"body": [
			"for ($1 = $2; $3; $4) begin",
			"    $0",
			"end"
		],
		"description": "for (...) begin ... end"
	},

	"while loop": {
		"prefix": "while",
		"body": [
			"while ($1) begin",
			"    $2",
			"end"
		],
		"description": "while (...) begin ... end"
	},

    
	"task":{
		"prefix":"task",
		"body":[
			"task ${1:automatic} ${2:taskName};",
            " \tinput    $3;",
            " \tinput    $4;",
            " \toutput   $5;",
			"    $0",
			"endtask //${1}"
		],
		"description":"task name; ... endtask"
	},

	"function": {
		"prefix": "function",
		"body": [
			"function $1;",
			"    $2;",
			"    $3",
			"endfunction"
		],
		"description": "function (...) ... endfunction"
	},

	"bit":{
		"prefix":"bit",
		"body":"bit"
	},

	"int":{
		"prefix":"int",
		"body":"int"
	},

	"byte":{
		"prefix":"byte",
		"body":"byte"
	},

	"logic":{
		"prefix":"logic",
		"body":"logic"
	},

    "reg": {
        "prefix": "reg",
        "body": [
            "reg $1;"
        ],
        "description": "reg reg_name;"
    },
    
    "regarray": {
        "prefix": "rega",
        "body": [
            "reg [$1:$2] $3;"
        ],
        "description": "reg [N:0] reg_name;"
    },
    
    "regmemory": {
        "prefix": "regm",
        "body": [
            "reg [$1:$2] $3 [$4:$5];"
        ],
        "description": "reg [N:0] reg_name [0:M];"
    },
    
    "wire": {
        "prefix": "wire",
        "body": [
            "wire $1;"
        ],
        "description": "wire wire_name;"
    },
    
    "wirearray": {
        "prefix": "wirea",
        "body": [
            "wire [$1:$2] $3;"
        ],
        "description": "wire [N:0] wire_name;"
    },

	"packed":{
		"prefix":"packed",
		"body":"packed"
	},

	"this":{
		"prefix": "this",
		"body": "this"
	},

	"array":{
		"prefix":"array",
		"body":"[${1:8}:${2:0}]$0",
		"description":"insert [x:y]"
	},

	"typedef struct packed":{
		"prefix":"typedefstructpacked",
		"body":[
			"typedef struct packed {",
			"    $0",
			"} ${1:struct_name};"
		],
		"description":"typedef struct packed { ... } name"
	},

	"class":{
		"prefix":"class",
		"body":[
			"class ${1:className};",
			"\tfunction new();",
			"        $0",
			"\tendfunction //new()",
			"endclass //${1}"
		],
		"description":"class name; ... endclass"
	},

	"class extends":{
		"prefix":"classextends",
		"body":[
			"class ${1:className} extends ${2:superClass};",
			"\tfunction new();",
			"        $0",
			"\tendfunction //new()",
			"endclass //${1} extends ${2}"
		],
		"description":"class name extends super; ... endclass"
	},


	"interface":{
		"prefix":"interface",
		"body":[
			"interface ${1:interfacename};",
			"    $0",
			"endinterface //${1}"
		],
		"description":"interface name; ... endinterface"
	},

	"display":{
		"prefix":"display",
		"body":[
			"$$display(\"${1}\"$2);$0"
		],
		"description":"$display(\"...\", params...)"
	},



	"typedef enum":{
		"prefix":"typedefenum",
		"body":[
			"typedef enum ${1:data_type} { $0 } ${2:name};"
		],
		"description":"typedef enum (data_type) { ... } name"
	},

	"enum":{
		"prefix":"enum",
		"body":[
			"enum ${1:data_type} { $0 } ${2:name}"
		],
		"description":"enum (data_type) { ... } name"
	},

	"queue":{
		"prefix":"queue",
		"body":"${1:data_type} ${2:queue_name}[$];",
		"description":"insert queue."
	},

	"mailbox":{
		"prefix":"mailbox",
		"body":[
			"mailbox mbx",
			"${1:mbx = new();}"
		],
		"description":"insert mailbox instance"
	},

	"Associative array":{
		"prefix":"AA",
		"body":"${1:data_type} ${2:name}[${3:index_type}];$0",
		"description":"insert Associative array(AA)."
	},

	"assert":{
		"prefix": "assert",
		"body": [
			"assert (${1:condition}) ${2}",
			"else   ${3:error_process}"
		],
		"description": "insert assert() ... else ..."
	},

	"fork-join":{
		"prefix": "forkjoin",
		"body": [
			"fork",
			"    $0",
			"join"
		],
		"description": "fork ... join"
	},

	"forever":{
		"prefix": "forever",
		"body": [
			"forever begin",
			"    $0",
			"end"
		],
		"description": "forever begin ... end"
	},
    
    "wavedrom comment": {
        "prefix" : "wavedrom",
        "body": [
            "/* @wavedrom",
            "{",
            "    $1",
            "}",
            "*/"
        ]
    },
    "random" : {
		"prefix": "$random",
		"body": [
			"\\$random($1)"
		],
		"description": ""
	}
}